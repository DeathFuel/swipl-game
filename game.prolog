rae("\
lllllllllllll\
l           l\
l           l\
l           l\
>           l\
>           l\
>           l\
l           l\
l           l\
l           l\
lllllnNnlllll").

rad("\
lllllllllllll\
l   lll  llll\
le   lll  lll\
l     lll  ll\
l      >     \
l      >     \
_      >     \
_     lll  ll\
_    lll  lll\
_   lll  llll\
lllllllllllll").

rac("\
lllllllllllll\
llSlSlSlSlSll\
lS S S S S Sl\
l           l\
l           l\
l  e  l   e l\
l     l      \
_     lrr    \
_     le e   \
_     l e r  \
lllllllllllll").

rab("\
lllllllllllll\
_       e   l\
lllllllllll l\
lllllllllll l\
l    e      l\
l lllllllllll\
l llSlllllSll\
l       e   _\
l           _\
l ll  ll  ll_\
l lllllllllll").

raa("\
lllllllllllll\
l           _\
l lSlllSlSlSl\
l lllllllllll\
l           l\
l           l\
l   lflfl   l\
l   lllll   l\
l           l\
le         el\
lll       lll").

rbe("\
lllllllllllll\
ldddd   ddddl\
ld         dl\
ld y     y dl\
ld         dl\
ld    x  > dl\
ld    p    dl\
ld y     y dl\
ld         dl\
ldddddddddddl\
lllllllllllll").

rbd("\
bbbbbbbbbbbbb\
_         bbb\
_ bbbb     bb\
bbbbbbr e  bb\
bbe  e     bb\
be re e r   b\
b e ee bb   b\
be r  bbb   b\
bbe  bbb    b\
bbbbbb     bb\
bbbb      bbb").

rbc("\
bbbbbbbbbbbbb\
_  bbbbbbb  _\
_   bbbbb   _\
bb   bbb   bb\
bbb  bbb   bb\
bbb   bb e bb\
bber  b    bb\
be   e    reb\
bbe     r eeb\
bbbbbbb   e b\
bbbbbbbbbbbbb").

rbb("\
b bbbbbbbbbbb\
b  > e bbb  _\
bbbb   >    _\
bb   bbb  r b\
b e bbbb e  b\
b   bbbb   bb\
b r bbbbrr bb\
b    bb  < bb\
bb   b   bbbb\
bb        bbb\
b         bbb").

rba("\
lll       lll\
lS         Sl\
l    lSl    l\
l f  lll  f l\
l           l\
lll       lll\
l     S     l\
l   lllll   l\
l           l\
lS         Sl\
lll       lll").

rce("\
bbbbbbbbbbbbb\
bbbbbbbbbbbbb\
_          bb\
_   r   r  bb\
bb         bb\
bb    k    bb\
bb         bb\
bb  r   r  bb\
bb         bb\
bb         bb\
bb         bb").

rcd("\
bbbb      bbb\
bbb      bbbb\
bbb     bb  _\
bbb uv  bb  _\
_ bb   bbb  b\
_  <  bbbb  b\
_  bbbbb    b\
b    bb  b  b\
bb    < bb rb\
bbbbbbbbbbrbb\
bbbbbbbbbbbbb").

rcc("\
bbbbbbbbbbbbb\
bbbbbbbbbbbbb\
bbbb       bb\
bbb         b\
b   e   e   _\
_           _\
_   rrrrr   _\
b           b\
bb         bb\
bb       bbbb\
bbbbbb bbbbbb").

rcb("\
b         bbb\
b         bbb\
b          bb\
b  rr  e    b\
b    rr     b\
bb     rr   _\
bb          _\
bbb  e      b\
bbb        bb\
bbbbbb   bbbb\
bbbbbbbbbbbbb").

rca("\
lll       lll\
l           l\
l           l\
llSlllSlllSll\
l           l\
l           l\
l           l\
l S       S l\
l           l\
llll     llll\
llll     llll").

rde("\
bb         bb\
bb          b\
bb          b\
b  f  r     b\
b       f  bb\
b r r      bb\
bbe eb   r bb\
bb e br    bb\
b b bb    bbb\
b b bbb  bbbb\
b b bbb  bbbb").

rdd("\
bbbbbbbbbbbbb\
bb         bb\
b  X??????  b\
b   Y????   b\
b   Z????   b\
_           b\
b     B     b\
b   B p B   b\
b   p   p   b\
bb         bb\
bbbbbbbbbbbbb").

rdc("\
bbbbbb bbbbbb\
bbbbbb bbbbbb\
bbbbcb bbbbbb\
bbb    bbbbbb\
bb      bbbbb\
_           _\
bb         bb\
bb         bb\
bb         bb\
bbbbbbbbbbbbb\
bbbbbbbbbbbbb").

cdc("\
ddddddddddddd\
ddddddddddddd\
dd T?????? dd\
dd U?????? dd\
dd  V????  dd\
dd   F??   dd\
dd    s    dd\
dd         dd\
dd         dd\
dddddd dddddd\
dddddd dddddd").

rdb("\
bbbbbbbbbbbbb\
bbb     bbbbb\
b   r     bbb\
_      r   bb\
_ r        bb\
_    f   r  _\
_          bb\
_  r       bb\
b      r  bbb\
bbb      bbbb\
bbbbb   bbbbb").

rda("\
bbbb     bbbb\
bbblggGgglbbb\
bbbb     bbbb\
bbbb        _\
bbbb        _\
bbbb        _\
bbbb        _\
bbbb        _\
bbbbbbbbbbbbb\
bbbbbbbbbbbbb\
bbbbbbbbbbbbb").

ree("\
d d ddd  dddd\
d d dddd   dd\
_ d     dd  d\
ddddddd  d  d\
dd       dd d\
_   ddddddd d\
dddddd  dd  d\
dddd  f dd  d\
_  d     d dd\
dd    d    dd\
ddddddddddddd").

red("\
ddddddddddddd\
_      dddddd\
_       ddd _\
dddd  f  d  d\
dddddd      d\
dddddddd    _\
_    dddd  dd\
_ dd e dd   d\
dddd e ddd  _\
_     ddddddd\
ddddddddddddd").

rec("\
ddddddddddddd\
dd    ddddd _\
d  dd  dd   _\
d  dd  d   dd\
_ dd  dd fddd\
dd   dd   ddd\
d f ddd  dd _\
d  ddddd    _\
d     ddddddd\
ddd f       _\
ddddddddddddd").

reb("\
bbbbb   bbbbb\
bbbbb     bbb\
bbbbb      bb\
bbbb     r  b\
bbbb        _\
bbb       r b\
bbb  f     bb\
bb r       bb\
b    r  f bbb\
_ r     bbbbb\
bbbbbbbbbbbbb").

rea("\
ddddddddddddd\
ddddddddddddd\
dd         dd\
dd  f r f  dd\
dd         dd\
dd  r C r  dd\
dd         dd\
dd  f r f  dd\
dd         dd\
dd          _\
ddddddddddddd").

dbg(Mesg) :- nl, write(Mesg), nl, sleep(1).

t :- t(0).
t(N) :- N1 is N + 100, write(N), write(' to '), write(N1), write(' :'), ((between(N, N1, X), name(T, [X]), write(T), fail); true, get0(_), t(N1)).

% the program is allowed to remember these, other vars are reset in l/0
:- dynamic has_key/0.
:- dynamic has_sword/0.
:- dynamic has_compass/0.
:- dynamic has_mystery/0.
:- dynamic gate_unlocked/0.
:- dynamic sword_upgraded/0.

l :-  % init and cleanup
	write('\e[H\e[2J'),
	retractall(attacktimer(_)),			asserta(attacktimer(0)),		% >0 means the player is attacking and cannot move
	retractall(roomdata(_)), rdc(X),	asserta(roomdata(X)),			% current room string
	retractall(roompos(_)),				asserta(roompos(17)),			% position of current room in the map
	retractall(position(_)),			asserta(position(84)),			% position of player in the current room
	retractall(direction(_)),			asserta(direction(0)),			% 0123<->NWSE
	retractall(timer(_)),				asserta(timer(0)),				% tickcount mod 40320 = 8!
	retractall(immunity_frames(_)),			asserta(immunity_frames(0)),
	retractall(health(_)),				asserta(health(3)),
	retractall(attackpos(_)),											% sword position
	retractall(spider(_, _)),											% enemy args (position, time_offset)
	retractall(flying(_, _)),											% flying enemy, args as above
	retractall(statue(_, _)),											% lol
	retractall(player_in_cave),
	retractall(fb(_, _)),
	retractall(fbdmg(_)),				asserta(fbdmg(0)),
	main_loop.
l :-
	(health(H), H < 1) -> (nl,
		write('Game over!'),
		nl, write('You can call the predicate again to retry.'),
		nl, write('Major progress (items, etc...) is saved unless you close Prolog.')
	); true.


main_loop :-
	repeat, (
		update_hud,
		roomdata_c(RD),
		update_display(RD, 0),
		nl,
		catch((call_with_time_limit(0.02, get_single_char(X))), _, true),
		write('\e[H\e[2J'),
		(nonvar(X) -> (
			[X] = "q" -> (!, fail); process_input(X)
		); true),
		process_enemies,
		process_timed_events,
		sleep(0.03),
		((health(H), H < 1) -> (!, fail), true)
	), nl, fail. % fdl


process_input(_) :- attackpos(_), !.
process_input(InputCode) :- 
	string_chars(X,[InputCode]),
	(
		X = "w" -> move(0);
		X = "a" -> move(1);
		X = "s" -> move(2);
		X = "d" -> move(3);
		member(X, ["z", "x", "c"]) -> attack;
		true
	).


% compatibility fix
roomdata_c(RDC) :-
	roomdata(RD),
	string_codes(RD, RDC).

move(Dir) :-
	retract(direction(_)), asserta(direction(Dir)),
	position(P),
	PM is P mod 13,
	( % this branch fails if no room switch occurs
		(Dir = 0, P < 13)  -> switch_room(-5);
		(Dir = 1, PM = 0)  -> switch_room(-1);
		(Dir = 2, P > 130) -> switch_room(5);
		(Dir = 3, PM = 12) -> switch_room(1)
	) -> ( % room switch, flip position
		retract(position(P)),
		(
			Dir = 0 -> M =  130;
			Dir = 1 -> M =  12;
			Dir = 2 -> M = -130;
			Dir = 3 -> M = -12
		),
		P1 is P + M,
		asserta(position(P1))
	);
	( % no room switch, move as normal
		position(P),
		roomdata_c(RD),
		(
			Dir = 0 -> M = -13;
			Dir = 1 -> M = -1;
			Dir = 2 -> M =  13;
			Dir = 3 -> M =  1
		),
		P1 is P + M,
		notcolliding(player, RD, P1) -> (
			retract(position(P)), asserta(position(P1))
		); true
	).


attack :- not(has_sword), !.
attack :-
	position(Pos),
	direction(Dir),
	PM is Pos mod 13,
	(sword_upgraded -> (
		Dir = 1, PM < 2;
		Dir = 3, PM > 10
	);(
		Dir = 1, PM = 0;
		Dir = 3, PM = 12
	)), !.
attack :-
	position(Pos),
	direction(Dir),
	roomdata_c(RD),
	(
		Dir = 0 -> M = -13;
		Dir = 1 -> M = -1;
		Dir = 2 -> M =  13;
		Dir = 3 -> M =  1
	),
	P1 is Pos + M,
	P2 is P1 + M,
	((notcolliding(sword, RD, P1)) -> (
		(attacktimer(_) -> asserta(attacktimer(8)); true), asserta(attackpos(P1))
	); true),
	(sword_upgraded, notcolliding(sword, RD, P2)) -> (
		(attacktimer(_) -> asserta(attacktimer(8)); true),  asserta(attackpos(P2))
	); true.


switch_room(c) :- % enter cave
	assert(player_in_cave),
	roompos(P),
	Y is P div 5 + 97,
	X is P mod 5 + 97,
	name(NewRoom, [99,Y,X]),
	call(NewRoom, NewRoomData),
	retract(roomdata(_)), asserta(roomdata(NewRoomData)),
	retract(position(_)), asserta(position(136)).
switch_room(M) :- % switch to non-cave room
	player_in_cave -> (
		retract(player_in_cave),
		rdc(NewRoomData),
		retract(roomdata(_)), asserta(roomdata(NewRoomData)),
		retract(position(_)), asserta(position(43))
	);
	roompos(P),
	P1 is P + M,
	between(0, 24, P1) -> (
		retract(roompos(_)),
		asserta(roompos(P1)),
		Y is P1 div 5 + 97,
		X is P1 mod 5 + 97,
		name(NewRoom, [114,Y,X]),
		call(NewRoom, NewRoomData),
		retract(roomdata(_)), asserta(roomdata(NewRoomData)),
		% room switched, process stuff like enemies and other effects
		retractall(spider(_, _)),
		retractall(flying(_, _)),
		retractall(statue(_, _)),
		retractall(fb(_, _)),
		roomdata_c(RD),
		process_room(RD, 0),
		(P1 = 4 -> asserta(fb(35,8)); true),
		(P1 = 18 -> retract(health(_)), asserta(health(3)); true)
	).

process_room([], _).
process_room([HCode|T], C) :-
	string_chars(H,[HCode]),
	(H = "e" -> random_between(0, 23, Offset), asserta(spider(C, Offset)); true),
	(H = "f" -> random_between(0, 11, Offset),  asserta(flying(C, Offset)); true),
	(H = "S" -> timer(TM), random_between(55, 59, O), Offset is (TM + O) mod 60, asserta(statue(C, Offset)); true),
	C1 is C + 1,
	process_room(T, C1).


% the player can trigger special effects which other collision checks shouldn't, hence the first argument
notcolliding(player, [TileCode|_], 0) :-
	string_chars(Tile,[TileCode]),
	(
		Tile = "c", switch_room(c);
		Tile = "k", (not(gate_unlocked), not(has_key) -> (asserta(has_key), fail); true);
		Tile = "s", (not(has_sword) -> (asserta(has_sword), fail); true);
		Tile = "C", (not(has_compass) -> (asserta(has_compass), fail); true);
		Tile = "x", (not(has_mystery) -> (asserta(has_mystery), retract(health(_)), asserta(health(3)), fail); true);
		Tile = "G", (has_key, not(gate_unlocked) -> (asserta(gate_unlocked), retract(has_key), !, fail); fail);
		Tile = "g", gate_unlocked;
		Tile = "G", gate_unlocked;
		Tile = "n", not(fb(_,_));
		Tile = "N", not(fb(_,_))
	).
notcolliding(_, [TileCode|_], 0) :-
	string_chars(Tile,[TileCode]),
	(
		Tile = "<", direction(1);
		Tile = ">", direction(3);
		Tile = " ";
		Tile = "_";
		member(Tile, ["e", "f", "S"]);
		(Tile = "u"; Tile = "v"), (not(sword_upgraded) -> ((not(has_sword) -> asserta(has_sword); true), asserta(sword_upgraded), fail); true)
	).
notcolliding(flying, [114|_], 0). % r
notcolliding(player, _, 0) :- has_mystery.
notcolliding(Caller, [_|Tail], Pos) :- 
	P1 is Pos - 1,
	notcolliding(Caller, Tail, P1).


process_timed_events :-
	retract(timer(T)),
	T1 is (T + 1) mod 40320,
	asserta(timer(T1)),
	(attacktimer(AT), AT > 0 -> (
		retract(attacktimer(AT)),
		AT1 is AT - 1,
		asserta(attacktimer(AT1))
	); ignore(retract(attackpos(_)))),
	immunity_frames(IF),
	(IF > 0 -> (
		retract(immunity_frames(IF)),
		IF1 is IF - 1,
		asserta(immunity_frames(IF1))
	); true),
	fbdmg(FBD),
	(FBD > 0 -> (
		retract(fbdmg(FBD)),
		FBD1 is FBD - 1,
		asserta(fbdmg(FBD1))
	); true).


immunity_flash :- immunity_frames(IF), IFM is (IF+1) div 5 mod 2, IFM = 0. % oscillating failure if IF > 0


process_enemies :-
	(
		(spider(Pos,Offset), (
			(
				attacktimer(AT),
				AT > 0,
				attackpos(Pos),
				retract(spider(Pos, Offset))
			); (
				timer(T),
				Offset is T mod 48,
				roomdata_c(RD),
				random_member(NP, [Pos-13, Pos-1, Pos+1, Pos+13]),
				NewPos is NP,
				notcolliding(spider, RD, NewPos),	% -  don't walk into walls
				not(spider(NewPos,_)),			% -  don't trip over each other
				between(13,130,NewPos),			% |
				NPM is NewPos mod 13,			% |- don't risk going OOB
				between(1,11,NPM),			% |
				retract(spider(Pos, Offset)),
				asserta(spider(NewPos, Offset))
			); (
				position(Pos), take_damage
			)
		), fail);
		(flying(Pos,Offset), (
			(
				attacktimer(AT),
				AT > 0,
				attackpos(Pos),
				retract(flying(Pos, Offset))
			); (
				timer(T),
				Offset is T mod 12,
				random_permutation([Pos-13, Pos-1, Pos+1, Pos+13], L),
				member(NP, L),
				NewPos is NP,
				roomdata_c(RD),
				notcolliding(flying, RD, NewPos),	% -  don't fly into walls, but rocks are fine
				not(flying(NewPos,_)),			% -  don't collide with each other
				not(statue(NewPos,_)),			% -  or statues
				between(13,130,NewPos),			% |
				NPM is NewPos mod 13,			% |- don't risk going OOB
				between(1,11,NPM),			% |
				retract(flying(Pos, Offset)),
				asserta(flying(NewPos, Offset))
			); (
				position(Pos), take_damage
			)
		), fail);
		(statue(Pos, Offset), (
			(
				attacktimer(AT),
				AT > 0,
				attackpos(Pos),
				retract(statue(Pos, Offset))
			); (
				timer(T),
				Offset is T mod 60,
				position(PlP),
				SX is Pos mod 13, SY is Pos div 13,
				PX is PlP mod 13, PY is PlP div 13,
				(DX is sign(PX - SX); DX is 0),
				(DY is sign(PY - SY); DY is 0),
				NewPos is Pos + DX + 13 * DY,
				roomdata_c(RD),
				notcolliding(statue, RD, NewPos),	% -  don't slide through walls
				not(statue(NewPos,_)),			% -  don't slide into each other
				not(flying(NewPos,_)),			% -  or into bats, but OOB is fine
				retract(statue(Pos, Offset)),
				asserta(statue(NewPos, Offset))
			); (
				position(Pos), take_damage
			)
		), fail);
		(fb(Pos, FBHealth), (
			(
				fbdmg(0),
				attacktimer(AT),
				AT > 0,
				( attackpos(Pos); 
					P1 is Pos + 1, attackpos(P1);
					P2 is Pos + 13, attackpos(P2);
					P3 is Pos + 14, attackpos(P3)
				), 
				retract(fb(Pos, FBHealth)),
				FBHealth > 1,
				retract(fbdmg(0)),
				NFBH is FBHealth - 1,
				asserta(fb(Pos, NFBH)),
				asserta(fbdmg(32))
			); (
				timer(T),
				0 is T mod 16,
				position(PlP),
				SX is Pos mod 13, SY is Pos div 13,
				PX is PlP mod 13, PY is PlP div 13,
				DistY is PY - SY,
				DistX is PX - SX,
				(between(0, 1, DistY) -> DY is 0; DY is sign(DistY)),
				(not(DY = 0), between(0, 1, DistX) -> DX is 0; DX is sign(DistX)),
				NewPos is Pos + DX + 13 * DY,
				retract(fb(Pos, FBHealth)),
				asserta(fb(NewPos, FBHealth)),
				findall(Sp,spider(Sp,_),Spiders), length(Spiders, SLen),
				0 is T mod ((1+SLen+SLen*SLen) * 4),
				random_between(0, 23, SpiderOffset),
				asserta(spider(Pos, SpiderOffset))
			); (
				( position(Pos); 
					P1 is Pos + 1, position(P1);
					P2 is Pos + 13, position(P2);
					P3 is Pos + 14, position(P3)
				), take_damage
			)
		))
	); true.

take_damage :- has_mystery, !.
take_damage :-
	immunity_frames(0),
	retract(immunity_frames(0)),
	retract(health(H)),
	H1 is H - 1,
	assert(health(H1)),
	asserta(immunity_frames(48)).

update_hud :-
	format('~s', [[9556,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9559]]), nl,
	format('~s ', [[9553]]),
	(has_sword -> (
		(sword_upgraded -> format('~s',[[8212,8212,10238]]); format(' -~s',[[10238]]))
	); write('   ')),
	(has_key -> format('  ~s ', [[9919]]); write('    ')),
	(has_compass -> (
		roompos(RP),
		X is RP mod 5 + 1,
		Y is RP div 5 + 1,
		format(' (~d, ~d) ', [X, Y])
	); write('  LIFE  ')),
	(has_mystery ->
		(maybe -> name(Heart, [32,9004]); name(Heart, [32,9187]));
	name(Heart, [32,9829])),
	health(H),
	(C is 3 - H, (between(1,3,D), (C < D -> write(Heart); write('  ')), fail); true),
	format('  ~s',[[9553]]),
	nl,
	format('~s', [[9562,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9552,9565]]).


update_display([], _).
update_display(Data, C) :-
	Data = [TileCode|DT],
	string_chars(Tile,[TileCode]),
	roompos(RP),
	(player_in_cave -> CL is (C+RP+1) mod 2; CL is (C+RP) mod 2),
	CM is C mod 13,
	(CM = 0 -> nl; true),
	(
		(position(P), P = C, immunity_flash) -> (
			(
				direction(D),
				(
					D = 0 -> write('/\\');
					D = 1 -> write('<=');
					D = 2 -> write('\\/');
					write('=>')
				)
			)
		);
		Tile = "l" -> (CL = 0 -> name(T,[9619,9619]); name(T,[9608,9608]));
		Tile = "b" -> (CL = 0 -> name(T,[9618,9618]); name(T,[9619,9619]));
		Tile = "d" -> (CL = 0 -> name(T,[9617,9617]); name(T,[9618,9618]));
		(attackpos(AP), AP = C, immunity_flash) -> (
			direction(D),
			(
				D = 0 -> write(',|');
				D = 1 -> write('-}');
				D = 2 -> write('`|');
				write('{-')
			)
		);
		(flying(Pos, Offset), Pos = C) -> (
			timer(TM), TMod is ((Offset+TM) div 2) mod 4,
			(
				TMod = 0 -> name(T,[8972,8973]);
				TMod = 2 -> name(T,[8974,8975]);
				name(T,[8765,8764])
			)
		);
		(statue(Pos, _), Pos = C) -> (
			name(T,[9608,9608])
		);
		(fb(Pos, _), fbdmg(FBD), 0 is FBD div 2 mod 2, timer(TM), TMod is TM div 9 mod 2, ((C = Pos); (C is Pos + 1); (C is Pos + 13); (C is Pos + 14))) -> (
			C = Pos -> name(T,[9052,9052]);
			C is Pos + 1 -> name(T,[9052,32]);
			C is Pos + 13 -> (TMod = 0 -> name(T,[9127,9127]); name(T,[9121,9121]));
			C is Pos + 14 -> (TMod = 0 -> name(T,[9131,9131]); name(T,[9124,9124]))
		);
		(flying(Pos, Offset), Pos = C) -> (
			timer(TM), TMod is ((Offset+TM) div 2) mod 4,
			(
				TMod = 0 -> name(T,[8972,8973]);
				TMod = 2 -> name(T,[8974,8975]);
				name(T,[8765,8764])
			)
		);
		(spider(Pos, Offset), Pos = C) -> (
			timer(TM), TMod is ((Offset+TM) div 12) mod 2,
			(TMod = 0 -> name(T,[10923,10922]); name(T,[8715,8712]))
		);
		(member(Tile,[" ", "_", "e", "f", "S"])) -> write('  ');
		Tile = "r" -> (L is round(sqrt(6007 * RP + 6037 * C)) mod 5 + 129857, R is round(1 + sqrt(6011 * RP + 6029 * C)) mod 5 + 129868, name(T,[L,R]));
		Tile = "y" -> (random_between(129857,129862,L), random_between(129868,129873,R), name(T,[L,R]));
		Tile = "n" -> (not(fb(_,_)) -> write('  '); name(T,[129803,129803]));
		Tile = "N" -> (not(fb(_,_)) -> write('  '); name(T,[129844,129848]));
		Tile = "g" -> (gate_unlocked -> write('  '); name(T,[129803,129803]));
		Tile = "G" -> (gate_unlocked -> write('  '); name(T,[129844,129848]));
		Tile = "C" -> (has_compass -> write('  '); name(T,[9202,32]));
		Tile = "k" -> ((has_key; gate_unlocked) -> write('  '); name(T,[9711,5763]));
		Tile = "x" -> (has_mystery -> write('  '); name(T,[9004,5764]));
		Tile = "s" -> (has_sword -> write('  '); name(T,[45,10238]));
		Tile = "u" -> (sword_upgraded -> write('  '); name(T,[8212, 8212]));
		Tile = "v" -> (sword_upgraded -> write('  '); name(T,[10238, 32]));
		Tile = "p" -> (name(T,[129859,129870]));
		Tile = "c" -> (name(T,[129883,129894]));
		Tile = "<" -> (name(T,[129956,129956]));
		Tile = ">" -> (name(T,[129957,129957]));
		Tile = "B" -> (name(T,[9004,9187]));
		Tile = "F" -> (name(T,[40,8976,9632,95,9632,41]));
		Tile = "T" -> (write('It\'s dangerous'));
		Tile = "U" -> (write(' to go alone, '));
		Tile = "V" -> (write('take this!'));
		Tile = "X" -> (write(' THE POWER OF '));
		Tile = "Y" -> (write('DEATH FUEL'));
		Tile = "Z" -> (write('HEALS YOU!'));
		true
	),
	(nonvar(T) -> write(T); true),
	C1 is C + 1,
	update_display(DT, C1).
